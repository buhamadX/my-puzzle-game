<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tetris Ultimate</title>
    <style>
        * { 
            touch-action: none !important; 
            -webkit-tap-highlight-color: transparent; 
            user-select: none; 
            -webkit-user-select: none;
            box-sizing: border-box; 
        }

        html, body { 
            position: fixed; overflow: hidden; width: 100%; height: 100%; 
            margin: 0; padding: 0; background: #050505; color: #fff; font-family: 'Segoe UI', sans-serif;
        }

        .app { display: flex; flex-direction: column; height: 100vh; }

        /* UI Header */
        .header { 
            height: 70px; display: flex; justify-content: space-around; align-items: center; 
            background: #111; border-bottom: 2px solid #00d2ff; box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
        }
        .stat { text-align: center; }
        .stat-lbl { font-size: 10px; color: #00d2ff; text-transform: uppercase; letter-spacing: 1px; }
        .stat-val { font-size: 20px; font-weight: 900; display: block; }

        /* Game Section */
        .game-viewport { flex-grow: 1; display: flex; justify-content: center; align-items: center; padding: 10px; gap: 10px; }
        canvas#t { background: #000; border: 2px solid #333; height: 100%; width: auto; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        
        .side-panel { display: flex; flex-direction: column; gap: 10px; align-self: flex-start; }
        .next-box { background: #111; border: 1px solid #444; padding: 5px; border-radius: 5px; text-align: center; }
        canvas#next { width: 60px; height: 60px; }

        /* Controls */
        .controls { height: 260px; display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; padding: 15px; background: #0a0a0a; }
        .btn { 
            background: #222; border-radius: 15px; display: flex; align-items: center; 
            justify-content: center; font-size: 24px; color: #fff; border: 1px solid #333;
            box-shadow: 0 4px 0 #000;
        }
        .btn:active { background: #333; transform: translateY(2px); box-shadow: 0 2px 0 #000; }
        
        #b-start { grid-column: span 3; background: #ff0055; border: none; font-size: 18px; font-weight: bold; box-shadow: 0 4px 0 #900; }
        .rotate { grid-column: span 3; border-color: #00d2ff; color: #00d2ff; }
    </style>
</head>
<body>

<div class="app">
    <div class="header">
        <div class="stat"><span class="stat-lbl">Score</span><span id="sc" class="stat-val">0</span></div>
        <div class="stat"><span class="stat-lbl">Level</span><span id="lv" class="stat-val">1</span></div>
        <div class="stat"><span class="stat-lbl">Best</span><span id="hi" class="stat-val">0</span></div>
    </div>

    <div class="game-viewport">
        <canvas id="t" width="240" height="400"></canvas>
        <div class="side-panel">
            <div class="next-box">
                <span class="stat-lbl">Next</span>
                <canvas id="next" width="80" height="80"></canvas>
            </div>
        </div>
    </div>

    <div class="controls">
        <div class="btn" id="b-start">START GAME</div>
        <div class="btn rotate" id="b-up">ROTATE</div>
        <div class="btn" id="b-left">←</div>
        <div class="btn" id="b-down">↓</div>
        <div class="btn" id="b-right">→</div>
    </div>
</div>

<script>
    const canvas = document.getElementById('t'), ctx = canvas.getContext('2d');
    const nCanvas = document.getElementById('next'), nCtx = nCanvas.getContext('2d');
    ctx.scale(20, 20);
    nCtx.scale(20, 20);

    const arena = Array.from({length: 20}, () => Array(12).fill(0));
    const colors = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];
    
    let score = 0, level = 1, last = 0, drop = 0, run = false;
    let nextPiece = null;
    let player = {pos: {x: 0, y: 0}, matrix: null};

    function create(t) {
        if (t === 'I') return [[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]];
        if (t === 'T') return [[0,2,0],[2,2,2],[0,0,0]];
        if (t === 'O') return [[3,3],[3,3]];
        if (t === 'L') return [[0,4,0],[0,4,0],[0,4,4]];
        if (t === 'J') return [[0,5,0],[0,5,0],[5,5,0]];
        if (t === 'S') return [[0,6,6],[6,6,0],[0,0,0]];
        if (t === 'Z') return [[7,7,0],[0,7,7],[0,0,0]];
    }

    function drawMatrix(matrix, offset, context, isGhost = false) {
        matrix.forEach((r, y) => r.forEach((v, x) => {
            if (v) {
                context.fillStyle = isGhost ? 'rgba(255,255,255,0.15)' : colors[v];
                context.fillRect(x + offset.x, y + offset.y, 1, 1);
                if (!isGhost) {
                    context.strokeStyle = 'rgba(0,0,0,0.5)';
                    context.lineWidth = 0.05;
                    context.strokeRect(x + offset.x, y + offset.y, 1, 1);
                }
            }
        }));
    }

    function draw() {
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,12,20);
        
        // Draw Grid
        ctx.strokeStyle = '#111'; ctx.lineWidth = 0.02;
        for(let i=0; i<12; i++) ctx.strokeRect(i,0,0,20);
        for(let i=0; i<20; i++) ctx.strokeRect(0,i,12,0);

        drawMatrix(arena, {x:0, y:0}, ctx);
        
        if(player.matrix) {
            // GHOST CALCULATION
            const ghost = {pos: {x: player.pos.x, y: player.pos.y}, matrix: player.matrix};
            while(!collide(arena, ghost)) ghost.pos.y++;
            ghost.pos.y--;
            drawMatrix(ghost.matrix, ghost.pos, ctx, true);
            
            drawMatrix(player.matrix, player.pos, ctx);
        }

        // NEXT PREVIEW
        nCtx.fillStyle = '#111'; nCtx.fillRect(0,0,4,4);
        if(nextPiece) drawMatrix(nextPiece, {x:0.5, y:0.5}, nCtx);
    }

    function collide(a, p) {
        const [m, o] = [p.matrix, p.pos];
        for(let y=0; y<m.length; ++y) for(let x=0; x<m[y].length; ++x)
            if(m[y][x]!==0 && (a[y+o.y] && a[y+o.y][x+o.x])!==0) return true;
        return false;
    }

    function reset() {
        const p = 'ILJOTSZ';
        player.matrix = nextPiece || create(p[p.length*Math.random()|0]);
        nextPiece = create(p[p.length*Math.random()|0]);
        player.pos = {y:0, x:4};
        if(collide(arena, player)) {
            arena.forEach(r=>r.fill(0));
            score=0; level=1;
        }
        updateStats();
    }

    function haptic() { if(window.navigator.vibrate) window.navigator.vibrate(10); }

    function dropP() {
        player.pos.y++;
        if(collide(arena, player)) {
            player.pos.y--;
            player.matrix.forEach((r,y)=>r.forEach((v,x)=>{ if(v) arena[y+player.pos.y][x+player.pos.x]=v; }));
            haptic();
            reset();
            sweep();
        }
        drop = 0;
    }

    function sweep() {
        let lines = 0;
        outer: for(let y=arena.length-1; y>0; --y) {
            for(let x=0; x<arena[y].length; ++x) if(arena[y][x]===0) continue outer;
            arena.splice(y,1); arena.unshift(new Array(12).fill(0));
            lines++; y++;
        }
        if(lines > 0) {
            score += [0, 10, 30, 50, 100][lines];
            level = Math.floor(score / 100) + 1;
            if(window.navigator.vibrate) window.navigator.vibrate([20, 10, 20]);
            updateStats();
        }
    }

    function updateStats() {
        document.getElementById('sc').innerText = score;
        document.getElementById('lv').innerText = level;
        let hi = localStorage.getItem('th') || 0;
        if(score > hi) { hi = score; localStorage.setItem('th', hi); }
        document.getElementById('hi').innerText = hi;
    }

    function update(t=0) {
        if(!run) return;
        const dt = t-last; last=t; drop+=dt;
        const speed = Math.max(100, 800 - (level * 50));
        if(drop > speed) dropP();
        draw(); requestAnimationFrame(update);
    }

    function listen(id, fn) {
        const el = document.getElementById(id);
        const trigger = (e) => { e.preventDefault(); fn(); draw(); };
        el.addEventListener('touchstart', trigger, {passive: false});
        el.addEventListener('mousedown', trigger);
    }

    listen('b-start', () => {
        if(run) return;
        run=true; document.getElementById('b-start').style.display='none';
        reset(); update();
    });
    listen('b-left', () => { player.pos.x--; if(collide(arena, player)) player.pos.x++; });
    listen('b-right', () => { player.pos.x++; if(collide(arena, player)) player.pos.x--; });
    listen('b-down', () => dropP());
    listen('b-up', () => {
        const m = player.matrix;
        for(let y=0; y<m.length; ++y) for(let x=0; x<y; ++x) [m[x][y], m[y][x]]=[m[y][x], m[x][y]];
        m.forEach(r=>r.reverse());
        if(collide(arena, player)) m.forEach(r=>r.reverse());
    });

    updateStats();
</script>
</body>
</html>
